First, determine the frequency of each character in the message. I used a dictionary to hold these values
because it allowed character to frequency (key to value). This part had a time complexity of O(n) and a space complexity of O(n).

Next, I built a list of nodes in the order lowest to highest frequencies. For this, I created a
priority queue with a list. Inserting nodes had a time complexity of O(1), but popping nodes
had a time complexity if O(n). The linked list also has a space complexity of O(n).

Then, I took two nodes with highest priority from the queue and created a new node from it, and then appended
it back into the list. This had a time complexity of O(n) and the space complexity remained the same.

Finally, I created the encodings.

When finding the decodings, I traversed through the tree until I found the character for each of the bits in the encoding. This
had a time and space complexity of O(n).